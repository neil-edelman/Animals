Unlike languages that have built-in support for dynamic-typing,
there's no one obvious one way to do object-oriented things in {C}. We
focus on the case where you have some collection of objects of
different types and you want to iterate and do something, often depending
on the type.
</p>

<p>
<img src = "Animals.png" width = 736 height = 738>
</p>

<p>
In this example, it separates the storage, most of the time {Pool},
from the data structure, {List}. {Pool} and {List} are generics
controlled by the pre-processor. The inheritance, denoted by a clear arrow,
is manifest in the code as nested {struct}s. By doing it this way, for example, you cannot refer to {bad_emu->name}, but {bad_emu->emu.animal.data.name}.
This explicitness favours shallow polymorphism.
</p>

<p>
{Pool} is a dynamic list, and
may move elements around in memory; any dependencies must be updated.
All the composition links, denoted by a black diamond, from a {Pool} or a descendant of a {Pool} must have a memory move function that corrects
the pointers. In this case, {emu%()}, says that in {emu_migrate()}, linked to {struct Emu} by, ({#define POOL_TYPE struct Emu}, {#define POOL_MIGRATE_EACH &emu_migrate}, #include "Pool.h"},) there is a case handing the pointed-at structure.
</p>

<p>
We have a virtual table for all virtual functions, (not shown,) one
for each {Animal}. If we were doing this in some other language, we might
have {MountInfo} be an interface.
